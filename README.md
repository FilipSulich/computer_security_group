# Notes for us:
To whomever is later writing the server part!!!:
To use the authorization method:
```python
import AccessControl from policy.py
ACCESS_CONTROL = AccessControl()
allowed, audit_log = authorize(user, operation, path)
```
user = user name
operation must be a supported operation (`realpath`, `stat`, `list`, `read`, `write`, `mkdir`, `remove`) -- map SFTP requests to these operations before calling
path = path to the file
example: authorize("alice", "read", "/public/file.txt")

Very important to call the authorize method after jail canonicalization via safe_join
and before any filesystem call!
# Readme

Things to write:
- how to run (on Windows/macOS/Linux), expected outputs, known limitations
- everything else regarding other sections of the project

## Pasword policy

Our password policy implements the following security measures:
1. Secure hashing - passwords are not stored in plaintext, hashes are generated by Argon2id
2. Secure password verification - constant-time comparison for scrypt hashes to prevent timing attacks
3. Account lockout - after 5 consecutive failed attemts the account is locked for 5 minutes
4. Rate limiting - maximum of 10 login attemts within a 1-minute window
5. Audit logging - all authentication events are logged to audit_auth.jsonl

### Loading
After initialisation of AccessControl if any of the data files fails to load properly the server exits and prints an error message. 

### Implementation
A single authorization gate returning True if and only if all 3 (DAC, MAC, RBAC) security systems return True. Every access (deny and allow) is logged in data/audit.jsonl ; For specific implementation read policy.md

### Data Files

**Authentication:**
- `data/users.json` - User credentials (username, salt, hashed password, hash parameters)

**Audit:**
- `data/audit.jsonl` - Access logs (both allowed and denied operations)

**RBAC:**
- `data/user_roles.json` - User → roles mapping
- `data/role_perms.csv` - Role permissions (role, resource, read, write, delete)

**MAC:**
- `data/mac_labels.json` - Clearance levels, user clearances, path classifications

**DAC:**
- `data/dac_owners.csv` - File ownership (path, owner, group, mode)
- `data/user_groups.json` - User → groups mapping

### Rules
Roles and clearance levels of users are defined as follows:
| **User**   | **Roles**      | **Clearance Level** | **Ownership**                          |
|------------|----------------|---------------------|----------------------------------------|
| **Alice**  | Intern         | Internal            | Owner of *reports*                     |
| **Bob**    | Intern         | Public              | —                                      |
| **James**  | Analyst        | Internal            | Owner of *project*                     |
| **Annie**  | Admin, Analyst | Confidential        | Owner of *admin*, *text*, and *policy* |

read/write permissions of each users are defined as followed:
| **File**    | **Alice (Intern)** | **Bob (Intern)** | **James (Analyst)** | **Annie (Admin, Analyst)** |
|-------------|--------------------|------------------|---------------------|----------------------------|
| **reports** | Read / Write       | Read             | -                   | -                          |
| **admin**   | -                  | -                | -                   | Read / Write               |
| **text**    | -                  | -                | -                   | Read / Write               |
| **project** | -                  | -                | Read / Write        | Read / Write               |
| **policy**  | -                  | -                | -                   | Read / Write               |


### Self-test
# Access Control Test Plan

This section describes the tests used to validate DAC, MAC, RBAC, composite tests and audits

# Access Control Test Plan

This section outlines what each test verifies for **DAC**, **MAC**, **RBAC**, **composite policies**, and **audit logging**.

---

## 1. DAC (Discretionary Access Control) Tests

These tests check that:

- The **file owner** can successfully **read and write** their own files.  
- **Non-owners** cannot **write** to files unless explicitly granted permission.  
- The **execute bit** on a directory properly controls the ability to **list (ls)** or **inspect (stat)** its contents.  
- Removing the execute bit denies file listing.

---

## 2. MAC (Mandatory Access Control) Tests

These tests verify that:

- A user with **Internal clearance** can **read** files classified as *Public* or *Internal*, but is **denied access** to *Confidential* files.  
- A user with **Confidential clearance** **cannot write down** to *Public* files or directories (to prevent data leaks).  
- The **read-up, no write-down** rule is consistently enforced across all MAC-protected resources.

---

## 3. RBAC (Role-Based Access Control) Tests

These tests confirm that:

- Users with the **Analyst** role can **read and write** under `/projects`.  
- Analysts **cannot create directories** under `/admin` unless given the **Admin** role.  
- Adding the **Admin** role grants **directory creation and modification privileges** under `/admin`.  
- If **per-user deny rules** are configured, those **override** any role-based allow permissions.

---

## 4. Composite Policy Tests

These tests ensure that:

- When **DAC allows** but **MAC denies** (or vice versa), the **final decision** matches the defined **policy composition rule**.  
- Combined access control logic is applied consistently, even in edge cases.  
- At least one **directory traversal attempt** is correctly **denied** due to the intersection of DAC and MAC restrictions.

---

## 5. Audit Assertions

These tests verify that:

- Every **allow** and **deny** decision **generates an audit record**.  
- Each audit log entry contains the required fields:  
  - **User** – the acting user  
  - **Action** – the operation attempted (e.g., read, write, mkdir)  
  - **Target** – the file or directory involved  
  - **Decision** – whether the action was allowed or denied  
  - **Policy Source** – which policy (DAC, MAC, RBAC, composite) determined the outcome  
- Logs are consistent, complete, and traceable for all access decisions.

---

## Server Implementation (server.py)

**1. SSH Transport via asyncssh (Requirement 1)**
- Uses asyncssh library for SSH transport, encryption, and key exchange
- Implements password-based authentication via `validate_user_password()`
- SFTP runs as SSH subsystem named 'sftp'
- Host key: Ed25519 key stored in `ssh_host_ed25519_key`
- Server listens on port 2222

**2. SFTP v3 Commands (Requirement 3)**
Implemented commands:
- `INIT/VERSION` - Protocol handshake
- `REALPATH` - Path canonicalization
- `STAT/LSTAT` - File attributes
- `OPENDIR/READDIR` - Directory listing
- `MKDIR` - Create directory
- `OPEN` - Open file for read/write
- `READ` - Read file data
- `WRITE` - Write file data
- `CLOSE` - Close handle

**3. Path Security**
- `canon_sftp_path()`: Converts SFTP paths to canonical POSIX format
- `safe_join()`: Prevents directory traversal attacks (jail enforcement)
- All paths validated before authorization and filesystem access

**4. Handle Management**
- `DirHandle`: Manages directory listing state
- `FileHandle`: Stores file object + canonical path for authorization on READ/WRITE
- Proper cleanup on CLOSE to prevent resource leaks

**5. Security Features**
- Default-deny policy
- Path traversal prevention
- Authorization on every file operation (including READ/WRITE)
- Proper error codes (PERMISSION_DENIED, NO_SUCH_FILE, etc.)
- No information disclosure in error messages

---

## Client Implementation (client.py)

### How It Meets Assignment Requirements

**1. SSH Connection**
- Connects via asyncssh to server
- Opens SFTP subsystem
- Implements password authentication
- Host key verification using TOFU (Trust On First Use)

**2. SFTP CLI Commands (Requirement 4)**
All required commands implemented:

| Command | What It Does | SFTP Operations |
|---------|--------------|-----------------|
| `pwd` | Print working directory | REALPATH |
| `ls [path]` | List directory contents | OPENDIR + READDIR |
| `mkdir <path>` | Create directory | MKDIR |
| `stat <path>` | Show file attributes | STAT |
| `get <rpath> [lpath]` | Download file | OPEN + READ + CLOSE |
| `put <lpath> <rpath>` | Upload file | OPEN + WRITE + CLOSE |
| `quit` | Exit session | - |

**3. User Experience**
- Interactive command prompt: `sftp>`
- Clear error messages for failed operations
- Graceful handling of SFTP errors
- Password prompt (hidden input via getpass)

**4. Protocol Compliance**
- Sends properly formatted SFTP v3 packets
- Handles server responses correctly
- Manages file handles for get/put operations
- Supports both absolute and relative paths

## CTF Flag
**Location:** `/confidential/admin/secrets/.hidden/flag.txt`  
**Flag:** `FLAG{group_CS_triple_layer_victory}`

The flag is protected by three independent security layers:
- **DAC**: File owned by annie with mode 0o400 (read-only for owner)
- **MAC**: Requires "confidential" clearance (only annie has this)
- **RBAC**: Requires "admin" role (only annie has this)

See `CTF_writeup.pdf` for complete analysis.

**Test successful access:**
```bash
python client/client.py
# Username: annie, Password: admin789
sftp> get /confidential/admin/secrets/.hidden/flag.txt ./flag.txt
```

**Test denied access:**
```bash
# Bob and James are blocked by all three layers
```
